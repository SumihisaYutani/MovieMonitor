# MovieMonitor 詳細設計書

## 1. システム概要

### 1.1 アーキテクチャ
- **アーキテクチャパターン**: MVVM (Model-View-ViewModel)
- **フレームワーク**: WPF + .NET 8
- **データベース**: LiteDB (NoSQL)
- **動画処理**: FFMpegCore
- **依存性注入**: Microsoft.Extensions.DependencyInjection

### 1.2 プロジェクト構成
```
src/
├── Models/                 # データモデル
├── Services/              # ビジネスロジック
├── ViewModels/            # MVVM ViewModels
├── Views/                 # XAML Views
├── Converters/            # データバインディング変換器
├── Extensions/            # 拡張メソッド
└── Resources/             # リソースファイル
```

## 2. 主要クラス設計

### 2.1 Models (データモデル)

#### VideoFile.cs
```csharp
public class VideoFile
{
    [BsonId]
    public string Id { get; set; }                    // 一意識別子
    [BsonField("file_path")]
    public string FilePath { get; set; }              // フルパス
    [BsonField("file_name")]
    public string FileName { get; set; }              // ファイル名
    [BsonField("file_size")]
    public long FileSize { get; set; }                // ファイルサイズ(バイト)
    [BsonField("duration")]
    public double Duration { get; set; }              // 再生時間(秒)
    [BsonField("width")]
    public int Width { get; set; }                    // 動画の幅(ピクセル)
    [BsonField("height")]
    public int Height { get; set; }                   // 動画の高さ(ピクセル)
    [BsonField("thumbnail_path")]
    public string? ThumbnailPath { get; set; }        // サムネイルパス
    [BsonField("created_at")]
    public DateTime CreatedAt { get; set; }           // ファイル作成日時
    [BsonField("modified_at")]
    public DateTime ModifiedAt { get; set; }          // ファイル最終更新日時
    [BsonField("scan_date")]
    public DateTime ScanDate { get; set; }            // スキャン日時
    [BsonField("is_deleted")]
    public bool IsDeleted { get; set; }               // 削除フラグ
    
    // 計算プロパティ
    public string Resolution => $"{Width}x{Height}";  // 解像度文字列
    public string FormattedFileSize => FormatFileSize(FileSize);  // "1.2 GB"形式
    public string FormattedDuration => FormatDuration(Duration);  // "01:23:45"形式
}
```

#### AppSettings.cs
```csharp
public class AppSettings
{
    public List<string> ScanDirectories { get; set; } = new();
    public int ThumbnailSize { get; set; } = 320;
    public string? DefaultPlayer { get; set; }
    public string? FFmpegPath { get; set; } = @"C:\ffmpeg\bin";
    public AppTheme Theme { get; set; } = AppTheme.Light;
    public DateTime? LastScanDate { get; set; }
    public List<VideoFormat> SupportedFormats { get; set; } = new()
    {
        VideoFormat.Mp4,
        VideoFormat.Avi,
        VideoFormat.Mkv,
        VideoFormat.Ts
    };
    public bool AutoScan { get; set; } = false;
    public int AutoScanInterval { get; set; } = 60;
    
    // ウィンドウ設定
    public double WindowWidth { get; set; } = 1200;
    public double WindowHeight { get; set; } = 800;
    public double WindowLeft { get; set; } = 100;
    public double WindowTop { get; set; } = 100;
    public bool WindowMaximized { get; set; } = false;
}

public enum AppTheme
{
    Light,
    Dark
}

// ディレクトリパス管理クラス
public class DirectoryPaths
{
    public string BaseDirectory { get; }
    public string DatabasePath { get; }
    public string ThumbnailDirectory { get; }
    public string LogDirectory { get; }
    public string TempDirectory { get; }
    public string ConfigDirectory { get; }
    public string ConfigFilePath { get; }
    
    public DirectoryPaths()
    {
        BaseDirectory = Path.GetDirectoryName(Environment.ProcessPath) 
            ?? AppContext.BaseDirectory;
        DatabasePath = Path.Combine(BaseDirectory, "data", "database.db");
        ThumbnailDirectory = Path.Combine(BaseDirectory, "thumbnails");
        LogDirectory = Path.Combine(BaseDirectory, "logs");
        TempDirectory = Path.Combine(BaseDirectory, "temp");
        ConfigDirectory = Path.Combine(BaseDirectory, "config");
        ConfigFilePath = Path.Combine(ConfigDirectory, "appsettings.json");
    }
}
```

### 2.2 Services (サービス層)

#### DatabaseService.cs
```csharp
public class DatabaseService : IDatabaseService
{
    private LiteDatabase? _database;
    
    // 主要メソッド
    public async Task InitializeAsync()
    public async Task<List<VideoFile>> SearchVideoFilesAsync(SearchFilter filter)
    public async Task SaveVideoFilesAsync(IEnumerable<VideoFile> videoFiles)
    public async Task DeleteVideoFileAsync(string id)
    public async Task CleanupDeletedFilesAsync()
    public async Task CleanupExcludedDirectoriesAsync(IEnumerable<string> scanDirectories)
    public async Task OptimizeDatabaseAsync()
}
```

**重要な実装詳細**:
- **インデックス最適化**: IsDeleted, ScanDate, FilePathにインデックス設定
- **トランザクション管理**: FindAll().ToList()でメモリロードによる同時実行エラー回避
- **クリーンアップ機能**: スキャン対象外ディレクトリの自動削除

#### VideoScanService.cs
```csharp
public class VideoScanService : IVideoScanService
{
    // 進捗通知イベント
    public event EventHandler<ScanProgress>? ProgressChanged;
    
    // 主要メソッド
    public async Task<ScanResult> ScanDirectoriesAsync(
        IEnumerable<string> directories, 
        CancellationToken cancellationToken)
    
    private async Task<VideoFile?> ProcessVideoFileAsync(string filePath)
    private void NotifyProgress(string currentFile, int processed, int total)
}
```

#### ThumbnailService.cs
```csharp
public class ThumbnailService : IThumbnailService
{
    public async Task<string?> GenerateThumbnailAsync(string videoPath, string outputPath)
    
    // FFmpeg設定とPNG生成
    private async Task ConfigureFFmpegAsync()
}
```

#### ConfigurationService.cs
```csharp
public class ConfigurationService : IConfigurationService
{
    // 設定変更通知（即座反映用）
    public event EventHandler<AppSettings>? SettingsChanged;
    
    public async Task<AppSettings> GetSettingsAsync()
    public async Task SaveSettingsAsync(AppSettings settings)
}
```

### 2.3 ViewModels (MVVM)

#### MainViewModel.cs
```csharp
public partial class MainViewModel : ObservableObject
{
    // ObservableProperty（自動プロパティ変更通知）
    [ObservableProperty] private ObservableCollection<VideoFile> _videos = new();
    [ObservableProperty] private ObservableCollection<VideoFile> _filteredVideos = new();
    [ObservableProperty] private bool _isLoading;
    [ObservableProperty] private string _loadingMessage = "";
    [ObservableProperty] private string _searchQuery = "";
    [ObservableProperty] private AppSettings _settings = new();
    
    // ランダム再生関連プロパティ
    [ObservableProperty] private bool _isRandomPlayModeEnabled = false;
    [ObservableProperty] private VideoFile? _currentlyPlayingVideo;
    private List<VideoFile> _randomPlaylist = new();
    private int _currentPlayIndex = -1;
    
    // 計算プロパティ（設定変更の即座反映）
    public int ThumbnailSize => Settings.ThumbnailSize;
    
    // コマンド
    public ICommand ScanCommand => new AsyncRelayCommand(ScanAsync);
    public ICommand PlayVideoCommand => new AsyncRelayCommand<VideoFile>(PlayVideo);
    public ICommand MoveVideoCommand => new AsyncRelayCommand<VideoFile>(OpenVideoLocation);
    public ICommand DeleteVideoCommand => new AsyncRelayCommand<VideoFile>(DeleteVideo);
    
    // ランダム再生コマンド
    public ICommand CreateRandomPlaylistCommand => new RelayCommand(CreateRandomPlaylist);
    public ICommand NextVideoCommand => new AsyncRelayCommand(PlayNextVideo);
    public ICommand PreviousVideoCommand => new AsyncRelayCommand(PlayPreviousVideo);
    public ICommand StopRandomPlayCommand => new RelayCommand(StopRandomPlay);
    
    // 設定変更イベントハンドラ（即座反映）
    private void OnSettingsChanged(object? sender, AppSettings newSettings)
    {
        Application.Current.Dispatcher.Invoke(() =>
        {
            var oldScanDirectories = Settings.ScanDirectories.ToList();
            Settings = newSettings;
            OnPropertyChanged(nameof(ThumbnailSize));
            
            // スキャンフォルダ変更時の自動クリーンアップ
            if (!oldScanDirectories.SequenceEqual(newSettings.ScanDirectories))
            {
                _ = Task.Run(async () => {
                    await _databaseService.CleanupExcludedDirectoriesAsync(newSettings.ScanDirectories);
                    await Application.Current.Dispatcher.InvokeAsync(async () => {
                        await LoadExistingVideosAsync();
                    });
                });
            }
        });
    }
    
    // ランダム再生機能
    private void CreateRandomPlaylist()
    {
        if (!FilteredVideos.Any())
        {
            ShowInfoMessage("ランダム再生", "表示中の動画がありません。");
            return;
        }
        
        var random = new Random();
        _randomPlaylist = FilteredVideos.OrderBy(x => random.Next()).ToList();
        _currentPlayIndex = -1;
        IsRandomPlayModeEnabled = true;
        
        StatusText = $"ランダムプレイリストを作成しました（{_randomPlaylist.Count}件）";
    }
    
    private async Task PlayNextVideo()
    {
        if (!IsRandomPlayModeEnabled || !_randomPlaylist.Any()) return;
        
        _currentPlayIndex++;
        if (_currentPlayIndex >= _randomPlaylist.Count)
        {
            StopRandomPlay();
            return;
        }
        
        var videoToPlay = _randomPlaylist[_currentPlayIndex];
        CurrentlyPlayingVideo = videoToPlay;
        await PlayVideo(videoToPlay);
        StatusText = $"再生中: {videoToPlay.FileName} ({_currentPlayIndex + 1}/{_randomPlaylist.Count})";
    }
    
    private async Task PlayPreviousVideo()
    {
        if (!IsRandomPlayModeEnabled || !_randomPlaylist.Any()) return;
        
        _currentPlayIndex = Math.Max(0, _currentPlayIndex - 1);
        var videoToPlay = _randomPlaylist[_currentPlayIndex];
        CurrentlyPlayingVideo = videoToPlay;
        await PlayVideo(videoToPlay);
        StatusText = $"再生中: {videoToPlay.FileName} ({_currentPlayIndex + 1}/{_randomPlaylist.Count})";
    }
    
    private void StopRandomPlay()
    {
        IsRandomPlayModeEnabled = false;
        _randomPlaylist.Clear();
        _currentPlayIndex = -1;
        CurrentlyPlayingVideo = null;
        StatusText = "ランダム再生を停止しました";
    }
}
```

#### SettingsViewModel.cs
```csharp
public class SettingsViewModel : INotifyPropertyChanged
{
    // スキャンフォルダ管理
    public ObservableCollection<string> ScanDirectories { get; }
    
    // 設定プロパティ
    public int ThumbnailSize { get; set; }
    public string FFmpegPath { get; set; }
    public AppTheme Theme { get; set; }
    
    // コマンド
    public ICommand AddDirectoryCommand => new RelayCommand(AddDirectory);
    public ICommand RemoveDirectoryCommand => new RelayCommand<string>(RemoveDirectory);
    public ICommand SaveCommand => new RelayCommand(SaveSettings);
    
    // フォルダ選択ダイアログ（WinForms使用）
    private void AddDirectory() {
        Application.Current.Dispatcher.Invoke(() => {
            using var dialog = new System.Windows.Forms.FolderBrowserDialog();
            // Win32ウィンドウハンドル取得でオーナー設定
        });
    }
}
```

## 3. UI設計 (XAML)

### 3.1 MainWindow.xaml
- **レイアウト**: Grid + RowDefinitions
- **メニューバー**: 標準WPFメニュー
- **ツールバー**: Material Design風ボタン
- **メインコンテンツ**: ItemsControl + WrapPanel
- **ローディング**: 1.5秒回転アニメーション

### 3.2 サムネイルカード設計
```xml
<Border Style="{StaticResource CardStyle}" 
        Width="{Binding DataContext.ThumbnailSize, RelativeSource={RelativeSource AncestorType=Window}, 
                Converter={StaticResource ThumbnailSizeToWidthConverter}}"
        Height="{Binding DataContext.ThumbnailSize, RelativeSource={RelativeSource AncestorType=Window}, 
                 Converter={StaticResource ThumbnailSizeToHeightConverter}}">
    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="{Binding DataContext.ThumbnailSize, 
                           Converter={StaticResource ThumbnailSizeToImageHeightConverter}}" />
            <RowDefinition Height="*" />
            <RowDefinition Height="Auto" />
        </Grid.RowDefinitions>
        
        <!-- サムネイル画像 + ホバーオーバーレイ -->
        <!-- ファイル情報（タグ形式） -->
        <!-- アクションボタン -->
    </Grid>
</Border>
```

### 3.3 データバインディング変換器

#### ThumbnailSizeConverters.cs
```csharp
// サムネイルサイズ → カード幅
public class ThumbnailSizeToWidthConverter : IValueConverter
{
    public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
    {
        if (value is int thumbnailSize)
        {
            return thumbnailSize + 32; // パディング考慮
        }
        return 352; // デフォルト
    }
}

// サムネイルサイズ → カード高さ
public class ThumbnailSizeToHeightConverter : IValueConverter
{
    // 16:9比率 + 情報エリア
}
```

## 4. データベース設計

### 4.1 LiteDB コレクション
```csharp
// video_files コレクション
{
    _id: string,                   // BsonId (GUID)
    file_path: string,             // ファイル絶対パス
    file_name: string,             // ファイル名
    file_size: long,               // ファイルサイズ(バイト)
    duration: double,              // 再生時間(秒)
    width: int,                    // 動画幅(ピクセル)
    height: int,                   // 動画高(ピクセル)
    thumbnail_path: string,        // サムネイルパス
    created_at: DateTime,          // ファイル作成日時
    modified_at: DateTime,         // ファイル更新日時
    scan_date: DateTime,           // スキャン日時
    is_deleted: boolean            // 論理削除フラグ
}

// インデックス設定（パフォーマンス最適化）
var videoFiles = database.GetCollection<VideoFile>("video_files");
videoFiles.EnsureIndex(x => x.FilePath, unique: true);
videoFiles.EnsureIndex(x => x.FileName);
videoFiles.EnsureIndex(x => x.FileSize);
videoFiles.EnsureIndex(x => x.Duration);
videoFiles.EnsureIndex(x => x.ScanDate);
videoFiles.EnsureIndex(x => x.IsDeleted);

// 複合インデックス（高速検索用）
videoFiles.EnsureIndex("IsDeleted_ScanDate", x => new { x.IsDeleted, x.ScanDate });
videoFiles.EnsureIndex("IsDeleted_FileName", x => new { x.IsDeleted, x.FileName });
videoFiles.EnsureIndex("IsDeleted_FileSize", x => new { x.IsDeleted, x.FileSize });
videoFiles.EnsureIndex("IsDeleted_Duration", x => new { x.IsDeleted, x.Duration });
```

### 4.2 クエリ最適化
```csharp
// 高速検索（インデックス最適化済み）
var query = collection.Query().Where(x => !x.IsDeleted); // 基本フィルタ（インデックス利用）

// 形式フィルタ（事前適用でメモリ削減）
if (filter.Formats.Count > 0)
{
    var extensions = filter.Formats.Select(f => f.GetExtension()).ToHashSet();
    query = query.Where(x => extensions.Any(ext => 
        x.FilePath.EndsWith(ext, StringComparison.OrdinalIgnoreCase)));
}

// 各種フィルタ（インデックス利用）
if (!string.IsNullOrEmpty(filter.Query))
    query = query.Where(x => x.FileName.Contains(filter.Query));

if (filter.MinSize.HasValue)
    query = query.Where(x => x.FileSize >= filter.MinSize.Value);

if (filter.MaxSize.HasValue)
    query = query.Where(x => x.FileSize <= filter.MaxSize.Value);

if (filter.MinDuration.HasValue)
    query = query.Where(x => x.Duration >= filter.MinDuration.Value);

if (filter.MaxDuration.HasValue)
    query = query.Where(x => x.Duration <= filter.MaxDuration.Value);

// ソート（複合インデックス利用）
query = query.OrderByDescending(x => x.ScanDate);

// ページネーション（メモリ上で実行）
var results = query.ToList();
if (filter.Offset.HasValue)
    results = results.Skip(filter.Offset.Value).ToList();
if (filter.Limit.HasValue)
    results = results.Take(filter.Limit.Value).ToList();
```

## 5. 重要な技術実装

### 5.1 設定の即座反映システム
```csharp
// ConfigurationService
public async Task SaveSettingsAsync(AppSettings settings)
{
    // JSON保存
    await SaveToFileAsync(settings);
    
    // イベント通知で即座反映
    SettingsChanged?.Invoke(this, settings);
}

// MainViewModel
private void OnSettingsChanged(object? sender, AppSettings newSettings)
{
    // UIスレッドで設定更新
    Application.Current.Dispatcher.Invoke(() =>
    {
        Settings = newSettings;
        OnPropertyChanged(nameof(ThumbnailSize)); // UI即座更新
    });
}
```

### 5.2 スキャン対象外フォルダのクリーンアップ
```csharp
public async Task CleanupExcludedDirectoriesAsync(IEnumerable<string> scanDirectories)
{
    var allFiles = collection.FindAll().ToList(); // メモリロードでエラー回避
    
    foreach (var file in allFiles)
    {
        bool isInScanDirectory = scanDirectories.Any(scanDir => 
            file.FilePath.StartsWith(scanDir, StringComparison.OrdinalIgnoreCase));
            
        if (!isInScanDirectory)
        {
            file.IsDeleted = true;
            collection.Update(file);
        }
    }
}
```

### 5.3 エクスプローラーでファイル選択
```csharp
private async Task OpenVideoLocation(VideoFile? video)
{
    var startInfo = new ProcessStartInfo
    {
        FileName = "explorer.exe",
        Arguments = $"/select,\"{video.FilePath}\"", // 選択状態で開く
        UseShellExecute = false
    };
    Process.Start(startInfo);
}
```

### 5.4 動的テーマシステム
モダンなライト・ダークテーマの切り替え機能を実装しています。

#### 5.4.1 テーマリソース構成
```
Resources/
├── Styles.xaml        # ライトテーマ (デフォルト)
└── DarkTheme.xaml     # ダークテーマ
```

#### 5.4.2 テーマ適用メカニズム
```csharp
// App.xaml.cs - 動的リソース切り替え
public void ApplyTheme(AppTheme theme)
{
    var resourceDict = new ResourceDictionary();
    
    switch (theme)
    {
        case AppTheme.Light:
            resourceDict.Source = new Uri("pack://application:,,,/Resources/Styles.xaml");
            break;
        case AppTheme.Dark:
            resourceDict.Source = new Uri("pack://application:,,,/Resources/DarkTheme.xaml");
            break;
    }
    
    // 既存のテーマリソースをクリアして新テーマを適用
    Resources.MergedDictionaries.Clear();
    Resources.MergedDictionaries.Add(resourceDict);
}
```

#### 5.4.3 設定連動システム
```csharp
// MainViewModel.cs - 設定変更の即座反映
partial void OnSettingsChanged(AppSettings value)
{
    OnPropertyChanged(nameof(ThumbnailSize));
    
    // テーマ変更の適用
    if (Application.Current is App app)
    {
        app.ApplyTheme(value.Theme);
    }
}

// SettingsViewModel.cs - テーマ設定の保存
private async void SaveSettings()
{
    _settings.Theme = Theme;  // UI選択値を保存
    await _configurationService.SaveSettingsAsync(_settings);
}
```

#### 5.4.4 テーマカラーパレット

**ライトテーマ** (`Resources/Styles.xaml`)
```xml
<Color x:Key="PrimaryColor">#2196F3</Color>
<Color x:Key="SurfaceColor">#FFFFFF</Color>
<Color x:Key="BackgroundColor">#FAFAFA</Color>
<Color x:Key="OnSurfaceColor">#212121</Color>
```

**ダークテーマ** (`Resources/DarkTheme.xaml`)
```xml
<Color x:Key="PrimaryColor">#6366F1</Color>
<Color x:Key="SurfaceColor">#1F2937</Color>
<Color x:Key="BackgroundColor">#111827</Color>
<Color x:Key="OnSurfaceColor">#F9FAFB</Color>
```

#### 5.4.5 DynamicResource使用によるリアルタイム反映
```xml
<!-- MainWindow.xaml - 動的テーマ反映 -->
<Window Background="{DynamicResource BackgroundBrush}">

<!-- SettingsWindow.xaml - 読みやすさ向上のため部分的に固定色使用 -->
<ListBox Background="White" Foreground="Black">  <!-- フォルダパス表示 -->
```

#### 5.4.6 エラー対策
- 両テーマで同一のリソースキーを定義（`CardStyle`など）
- Pack URI形式でリソース参照の安定性を確保
- プロジェクトファイルでのResource定義による確実な読み込み

## 6. パフォーマンス最適化

### 6.1 UI仮想化
- ItemsControlでVirtualizingStackPanel使用（大量データ対応）
- サムネイル遅延ロード

### 6.2 データベース最適化
- 複合インデックス設定
- クエリ実行計画最適化
- バッチ処理によるI/O削減

### 6.3 非同期処理
- すべてのI/Oは非同期
- UIスレッドブロック防止
- CancellationToken対応

## 7. エラーハンドリング

### 7.1 例外階層
```csharp
public abstract class MovieMonitorException : Exception { }
public class VideoProcessingException : MovieMonitorException { }
public class DatabaseException : MovieMonitorException { }
public class ConfigurationException : MovieMonitorException { }
```

### 7.2 包括的エラーハンドリング
- 各レイヤーでの適切な例外キャッチ
- ユーザーフレンドリーなエラーメッセージ
- ログ出力による詳細情報保存

## 8. バージョン更新履歴

### v1.0.0 (2025-08-30)
- ✅ 基本機能実装完了（動画スキャン・サムネイル生成・データベース検索）
- ✅ Material Design UI実装（レスポンシブカードレイアウト）
- ✅ 設定の即座反映機能（リアルタイム設定変更）
- ✅ エクスプローラーでファイルを開く機能（ファイル選択状態で開く）
- ✅ スキャン対象外フォルダの自動クリーンアップ
- ✅ ローディングアニメーション最適化（1.5秒回転アニメーション）
- ✅ LiteDB同時実行エラー修正（共有接続・メモリロード対応）
- ✅ サムネイルPNG形式生成（FFmpeg連携）
- ✅ 複合インデックス最適化（高速検索対応）
- ✅ DirectoryPathsクラス実装（ポータブルファイル管理）
- ✅ VideoFileモデル拡張（幅・高さ・作成日時・更新日時追加）
- ✅ ログ機能強化（Serilog・ファイル名行番号出力）
- ✅ エラーハンドリング包括対応
- ✅ Single File Executable対応（164MB独立実行ファイル）

### v1.1.0 (2025-08-31)
- ✅ **動的テーマシステム実装**（ライト・ダークテーマ対応）
- ✅ **設定画面のテーマ切り替え機能**
- ✅ **リアルタイムテーマ反映**（DynamicResource使用）
- ✅ **テーマリソース統一管理**（Resources/Styles.xaml・DarkTheme.xaml）
- ✅ **モダンダークテーマデザイン**（Material Design風カラーパレット）
- ✅ **設定ウィンドウUI改善**（ダークテーマでの視認性向上）
- ✅ **Pack URI形式リソース参照**（安定性向上）
- ✅ **テーマ切り替えエラー対策**（CardStyleリソース重複定義等）
- ✅ **設定保存・読み込み機能強化**（テーマ設定永続化）

### v1.2.0 (2025-10-25)
- ✅ **ランダム再生機能実装**（現在表示中の動画からプレイリスト作成）
- ✅ **順次再生機能**（ランダムプレイリストでの前/次動画移動）
- ✅ **再生制御UI**（ランダム再生・前・次・停止ボタン）
- ✅ **再生状態表示**（現在再生中の動画・プレイリスト位置表示）
- ✅ **ツールバー統合**（メインUIにランダム再生コントロールを配置）