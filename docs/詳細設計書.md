# MovieMonitor 詳細設計書

## 1. モジュール詳細設計

### 1.1 メインプロセスモジュール

#### 1.1.1 main.ts (アプリケーションエントリーポイント)
```typescript
class MovieMonitorApp {
  private mainWindow: BrowserWindow | null = null;
  private database: DatabaseManager;

  /**
   * アプリケーション初期化
   */
  public async initialize(): Promise<void> {
    await this.initializeDatabase();
    await this.createMainWindow();
    this.setupIPCHandlers();
  }

  /**
   * メインウィンドウ作成
   */
  private async createMainWindow(): Promise<void> {
    this.mainWindow = new BrowserWindow({
      width: 1200,
      height: 800,
      minWidth: 800,
      minHeight: 600,
      webPreferences: {
        nodeIntegration: false,
        contextIsolation: true,
        preload: path.join(__dirname, 'preload.js')
      }
    });
  }
}
```

#### 1.1.2 DatabaseManager (データベース管理)
```typescript
class DatabaseManager {
  private db: Database;

  /**
   * データベース初期化
   */
  public async initialize(): Promise<void> {
    const dbPath = path.join(app.getPath('userData'), 'moviemonitor.db');
    this.db = new Database(dbPath);
    await this.createTables();
    await this.createIndexes();
  }

  /**
   * 動画ファイル保存
   */
  public async saveVideoFile(videoFile: VideoFile): Promise<void> {
    const stmt = this.db.prepare(`
      INSERT OR REPLACE INTO video_files 
      (id, file_path, file_name, file_size, duration, width, height, 
       thumbnail_path, created_at, modified_at, scan_date)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `);
    
    stmt.run([
      videoFile.id,
      videoFile.filePath,
      videoFile.fileName,
      videoFile.fileSize,
      videoFile.duration,
      videoFile.width,
      videoFile.height,
      videoFile.thumbnailPath,
      videoFile.createdAt.toISOString(),
      videoFile.modifiedAt.toISOString(),
      videoFile.scanDate.toISOString()
    ]);
  }

  /**
   * 動画ファイル検索
   */
  public async searchVideoFiles(filter: SearchFilter): Promise<VideoFile[]> {
    let query = 'SELECT * FROM video_files WHERE is_deleted = FALSE';
    const params: any[] = [];

    if (filter.query) {
      query += ' AND file_name LIKE ?';
      params.push(`%${filter.query}%`);
    }

    if (filter.minSize) {
      query += ' AND file_size >= ?';
      params.push(filter.minSize);
    }

    if (filter.maxSize) {
      query += ' AND file_size <= ?';
      params.push(filter.maxSize);
    }

    if (filter.minDuration) {
      query += ' AND duration >= ?';
      params.push(filter.minDuration);
    }

    if (filter.maxDuration) {
      query += ' AND duration <= ?';
      params.push(filter.maxDuration);
    }

    query += ' ORDER BY scan_date DESC';
    
    const stmt = this.db.prepare(query);
    const rows = stmt.all(params);
    
    return rows.map(row => this.mapRowToVideoFile(row));
  }
}
```

#### 1.1.3 FileScanner (ファイルスキャナー)
```typescript
class FileScanner {
  private supportedFormats = ['.mp4', '.avi', '.mkv', '.ts'];

  /**
   * ディレクトリスキャン実行
   */
  public async scanDirectories(
    directories: string[],
    onProgress?: (progress: ScanProgress) => void
  ): Promise<VideoFile[]> {
    const results: VideoFile[] = [];
    let totalFiles = 0;
    let processedFiles = 0;

    // 総ファイル数の計算
    for (const dir of directories) {
      totalFiles += await this.countVideoFiles(dir);
    }

    for (const directory of directories) {
      const files = await this.scanDirectory(directory);
      
      for (const filePath of files) {
        try {
          const videoFile = await this.processVideoFile(filePath);
          results.push(videoFile);
          
          processedFiles++;
          onProgress?.({
            totalFiles,
            processedFiles,
            currentFile: path.basename(filePath)
          });
        } catch (error) {
          console.error(`Failed to process file: ${filePath}`, error);
        }
      }
    }

    return results;
  }

  /**
   * 単一ディレクトリの再帰スキャン
   */
  private async scanDirectory(directory: string): Promise<string[]> {
    const files: string[] = [];
    
    const scanRecursive = async (dir: string) => {
      try {
        const entries = await fs.readdir(dir, { withFileTypes: true });
        
        for (const entry of entries) {
          const fullPath = path.join(dir, entry.name);
          
          if (entry.isDirectory()) {
            await scanRecursive(fullPath);
          } else if (entry.isFile()) {
            const ext = path.extname(entry.name).toLowerCase();
            if (this.supportedFormats.includes(ext)) {
              files.push(fullPath);
            }
          }
        }
      } catch (error) {
        console.error(`Failed to scan directory: ${dir}`, error);
      }
    };

    await scanRecursive(directory);
    return files;
  }

  /**
   * 動画ファイル情報の処理
   */
  private async processVideoFile(filePath: string): Promise<VideoFile> {
    const stats = await fs.stat(filePath);
    const metadata = await this.extractMetadata(filePath);
    const thumbnailPath = await this.generateThumbnail(filePath);

    return {
      id: this.generateFileId(filePath),
      filePath,
      fileName: path.basename(filePath),
      fileSize: stats.size,
      duration: metadata.duration,
      width: metadata.width,
      height: metadata.height,
      thumbnailPath,
      createdAt: stats.birthtime,
      modifiedAt: stats.mtime,
      scanDate: new Date()
    };
  }
}
```

#### 1.1.4 MetadataExtractor (メタデータ抽出)
```typescript
class MetadataExtractor {
  /**
   * 動画メタデータ抽出
   */
  public async extractMetadata(filePath: string): Promise<VideoMetadata> {
    return new Promise((resolve, reject) => {
      const ffprobe = spawn('ffprobe', [
        '-v', 'quiet',
        '-print_format', 'json',
        '-show_format',
        '-show_streams',
        filePath
      ]);

      let data = '';
      ffprobe.stdout.on('data', (chunk) => {
        data += chunk;
      });

      ffprobe.on('close', (code) => {
        if (code === 0) {
          try {
            const metadata = JSON.parse(data);
            const videoStream = metadata.streams.find(
              (stream: any) => stream.codec_type === 'video'
            );

            resolve({
              duration: parseFloat(metadata.format.duration) || 0,
              width: videoStream?.width || 0,
              height: videoStream?.height || 0,
              bitrate: parseInt(metadata.format.bit_rate) || 0,
              codec: videoStream?.codec_name || 'unknown'
            });
          } catch (error) {
            reject(new Error(`Failed to parse metadata: ${error.message}`));
          }
        } else {
          reject(new Error(`ffprobe failed with code ${code}`));
        }
      });
    });
  }
}
```

#### 1.1.5 ThumbnailGenerator (サムネイル生成)
```typescript
class ThumbnailGenerator {
  private thumbnailDir: string;

  constructor() {
    this.thumbnailDir = path.join(app.getPath('userData'), 'thumbnails');
    this.ensureThumbnailDirectory();
  }

  /**
   * サムネイル生成
   */
  public async generateThumbnail(
    filePath: string,
    duration: number
  ): Promise<string> {
    const thumbnailFileName = this.getThumbnailFileName(filePath);
    const thumbnailPath = path.join(this.thumbnailDir, thumbnailFileName);

    // 既存のサムネイルがあれば使用
    if (await this.fileExists(thumbnailPath)) {
      return thumbnailPath;
    }

    // 動画の50%位置からサムネイル生成
    const timeOffset = Math.floor(duration / 2);
    
    return new Promise((resolve, reject) => {
      const ffmpeg = spawn('ffmpeg', [
        '-i', filePath,
        '-ss', timeOffset.toString(),
        '-vframes', '1',
        '-q:v', '2',
        '-s', '320x240',
        thumbnailPath,
        '-y'
      ]);

      ffmpeg.on('close', (code) => {
        if (code === 0) {
          resolve(thumbnailPath);
        } else {
          reject(new Error(`Thumbnail generation failed with code ${code}`));
        }
      });

      ffmpeg.on('error', (error) => {
        reject(error);
      });
    });
  }

  /**
   * サムネイルファイル名生成
   */
  private getThumbnailFileName(filePath: string): string {
    const hash = crypto.createHash('md5')
      .update(filePath)
      .digest('hex');
    return `${hash}.jpg`;
  }
}
```

### 1.2 レンダラープロセスモジュール

#### 1.2.1 VideoContext (状態管理)
```typescript
interface VideoState {
  videos: VideoFile[];
  filteredVideos: VideoFile[];
  isLoading: boolean;
  searchFilter: SearchFilter;
  selectedVideo: VideoFile | null;
  scanProgress: ScanProgress | null;
}

type VideoAction =
  | { type: 'SET_VIDEOS'; payload: VideoFile[] }
  | { type: 'SET_LOADING'; payload: boolean }
  | { type: 'SET_SEARCH_FILTER'; payload: SearchFilter }
  | { type: 'SET_SELECTED_VIDEO'; payload: VideoFile | null }
  | { type: 'SET_SCAN_PROGRESS'; payload: ScanProgress | null };

const VideoContext = React.createContext<{
  state: VideoState;
  dispatch: React.Dispatch<VideoAction>;
} | null>(null);

export const VideoProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [state, dispatch] = useReducer(videoReducer, initialState);
  
  return (
    <VideoContext.Provider value={{ state, dispatch }}>
      {children}
    </VideoContext.Provider>
  );
};
```

#### 1.2.2 useVideoOperations (カスタムフック)
```typescript
export const useVideoOperations = () => {
  const { state, dispatch } = useContext(VideoContext)!;

  const scanVideos = useCallback(async (directories?: string[]) => {
    dispatch({ type: 'SET_LOADING', payload: true });
    
    try {
      const videos = await window.electronAPI.scanVideos({ directories });
      dispatch({ type: 'SET_VIDEOS', payload: videos });
    } catch (error) {
      console.error('Failed to scan videos:', error);
    } finally {
      dispatch({ type: 'SET_LOADING', payload: false });
    }
  }, [dispatch]);

  const searchVideos = useCallback(async (filter: SearchFilter) => {
    dispatch({ type: 'SET_SEARCH_FILTER', payload: filter });
    dispatch({ type: 'SET_LOADING', payload: true });
    
    try {
      const videos = await window.electronAPI.searchVideos(filter);
      dispatch({ type: 'SET_VIDEOS', payload: videos });
    } catch (error) {
      console.error('Failed to search videos:', error);
    } finally {
      dispatch({ type: 'SET_LOADING', payload: false });
    }
  }, [dispatch]);

  const openVideo = useCallback(async (filePath: string) => {
    try {
      await window.electronAPI.openVideo({ filePath });
    } catch (error) {
      console.error('Failed to open video:', error);
    }
  }, []);

  const moveVideo = useCallback(async (from: string, to: string) => {
    try {
      const result = await window.electronAPI.moveVideo({ from, to });
      if (result) {
        // 状態更新
        const updatedVideos = state.videos.map(video =>
          video.filePath === from
            ? { ...video, filePath: to, fileName: path.basename(to) }
            : video
        );
        dispatch({ type: 'SET_VIDEOS', payload: updatedVideos });
      }
    } catch (error) {
      console.error('Failed to move video:', error);
    }
  }, [state.videos, dispatch]);

  const deleteVideo = useCallback(async (filePath: string) => {
    try {
      const result = await window.electronAPI.deleteVideo({ filePath });
      if (result) {
        // 状態から削除
        const updatedVideos = state.videos.filter(
          video => video.filePath !== filePath
        );
        dispatch({ type: 'SET_VIDEOS', payload: updatedVideos });
      }
    } catch (error) {
      console.error('Failed to delete video:', error);
    }
  }, [state.videos, dispatch]);

  return {
    videos: state.videos,
    isLoading: state.isLoading,
    searchFilter: state.searchFilter,
    scanVideos,
    searchVideos,
    openVideo,
    moveVideo,
    deleteVideo
  };
};
```

## 2. API設計

### 2.1 Electron IPC API
```typescript
// preload.js で公開するAPI
interface ElectronAPI {
  scanVideos(params: { directories?: string[] }): Promise<VideoFile[]>;
  searchVideos(filter: SearchFilter): Promise<VideoFile[]>;
  generateThumbnail(params: { filePath: string }): Promise<string>;
  openVideo(params: { filePath: string }): Promise<boolean>;
  moveVideo(params: { from: string; to: string }): Promise<boolean>;
  deleteVideo(params: { filePath: string }): Promise<boolean>;
  selectDirectory(): Promise<string | null>;
  showMessageBox(options: MessageBoxOptions): Promise<MessageBoxResponse>;
  
  // イベントリスナー
  onScanProgress(callback: (progress: ScanProgress) => void): void;
  onError(callback: (error: string) => void): void;
}

declare global {
  interface Window {
    electronAPI: ElectronAPI;
  }
}
```

## 3. エラーハンドリング詳細

### 3.1 エラー分類と処理
```typescript
enum ErrorType {
  FILE_ACCESS_ERROR = 'FILE_ACCESS_ERROR',
  DATABASE_ERROR = 'DATABASE_ERROR',
  METADATA_EXTRACTION_ERROR = 'METADATA_EXTRACTION_ERROR',
  THUMBNAIL_GENERATION_ERROR = 'THUMBNAIL_GENERATION_ERROR',
  VALIDATION_ERROR = 'VALIDATION_ERROR'
}

class VideoMonitorError extends Error {
  constructor(
    public readonly type: ErrorType,
    message: string,
    public readonly originalError?: Error
  ) {
    super(message);
    this.name = 'VideoMonitorError';
  }
}

// エラーハンドラー
class ErrorHandler {
  static handle(error: unknown): void {
    if (error instanceof VideoMonitorError) {
      switch (error.type) {
        case ErrorType.FILE_ACCESS_ERROR:
          this.handleFileAccessError(error);
          break;
        case ErrorType.DATABASE_ERROR:
          this.handleDatabaseError(error);
          break;
        // ... その他のエラー処理
      }
    } else {
      this.handleUnknownError(error);
    }
  }

  private static handleFileAccessError(error: VideoMonitorError): void {
    logger.error('File access error:', error);
    // ユーザーに権限確認を促すダイアログ表示
    dialog.showErrorBox(
      'ファイルアクセスエラー',
      'ファイルにアクセスできません。権限を確認してください。'
    );
  }
}
```

## 4. テスト設計

### 4.1 単体テスト
```typescript
// DatabaseManager のテスト例
describe('DatabaseManager', () => {
  let dbManager: DatabaseManager;

  beforeEach(async () => {
    dbManager = new DatabaseManager();
    await dbManager.initialize(':memory:'); // メモリDB使用
  });

  describe('saveVideoFile', () => {
    it('should save video file correctly', async () => {
      const videoFile: VideoFile = {
        id: 'test-id',
        filePath: '/test/path/video.mp4',
        fileName: 'video.mp4',
        fileSize: 1024000,
        duration: 120,
        width: 1920,
        height: 1080,
        thumbnailPath: '/test/thumb.jpg',
        createdAt: new Date(),
        modifiedAt: new Date(),
        scanDate: new Date()
      };

      await dbManager.saveVideoFile(videoFile);
      
      const savedFile = await dbManager.getVideoFile('test-id');
      expect(savedFile).toEqual(videoFile);
    });
  });
});

// FileScanner のテスト例
describe('FileScanner', () => {
  let scanner: FileScanner;

  beforeEach(() => {
    scanner = new FileScanner();
  });

  describe('scanDirectories', () => {
    it('should find video files in directory', async () => {
      // モックファイルシステム設定
      const mockFiles = [
        '/test/video1.mp4',
        '/test/video2.avi',
        '/test/document.txt' // 除外される
      ];

      jest.spyOn(fs, 'readdir').mockResolvedValue(mockFiles);
      
      const result = await scanner.scanDirectories(['/test']);
      
      expect(result).toHaveLength(2);
      expect(result[0].fileName).toBe('video1.mp4');
      expect(result[1].fileName).toBe('video2.avi');
    });
  });
});
```

### 4.2 統合テスト
```typescript
describe('Video Management Integration', () => {
  let app: Application;

  beforeAll(async () => {
    app = new Application({
      path: electron,
      args: [path.join(__dirname, '..', 'dist', 'main.js')],
      env: { NODE_ENV: 'test' }
    });
    
    await app.start();
  });

  afterAll(async () => {
    if (app && app.isRunning()) {
      await app.stop();
    }
  });

  it('should scan and display video files', async () => {
    // テスト用動画ファイル準備
    await app.client.waitUntilWindowLoaded();
    
    // スキャンボタンクリック
    await app.client.click('[data-testid="scan-button"]');
    
    // 結果表示待機
    await app.client.waitForExist('[data-testid="video-grid"]');
    
    // 動画カード数確認
    const videoCards = await app.client.$$('[data-testid="video-card"]');
    expect(videoCards.length).toBeGreaterThan(0);
  });
});
```

## 5. ビルド・デプロイ設定

### 5.1 Webpack設定
```typescript
// webpack.main.js
const path = require('path');

module.exports = {
  target: 'electron-main',
  entry: './src/main/main.ts',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'main.js'
  },
  module: {
    rules: [
      {
        test: /\.ts$/,
        use: 'ts-loader',
        exclude: /node_modules/
      }
    ]
  },
  resolve: {
    extensions: ['.ts', '.js']
  },
  externals: {
    'better-sqlite3': 'commonjs better-sqlite3'
  }
};

// webpack.renderer.js
module.exports = {
  target: 'electron-renderer',
  entry: './src/renderer/index.tsx',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'renderer.js'
  },
  module: {
    rules: [
      {
        test: /\.tsx?$/,
        use: 'ts-loader',
        exclude: /node_modules/
      },
      {
        test: /\.css$/,
        use: ['style-loader', 'css-loader']
      }
    ]
  },
  resolve: {
    extensions: ['.tsx', '.ts', '.js']
  }
};
```

### 5.2 Electron Builder設定
```json
{
  "build": {
    "appId": "com.moviemonitor.app",
    "productName": "MovieMonitor",
    "directories": {
      "output": "release",
      "assets": "assets"
    },
    "files": [
      "dist/**/*",
      "node_modules/**/*",
      "!node_modules/@types/**/*",
      "!node_modules/.bin/**/*"
    ],
    "win": {
      "target": [
        {
          "target": "nsis",
          "arch": ["x64"]
        },
        {
          "target": "portable",
          "arch": ["x64"]
        }
      ],
      "icon": "assets/icon.ico"
    },
    "nsis": {
      "oneClick": false,
      "allowToChangeInstallationDirectory": true,
      "createDesktopShortcut": true,
      "createStartMenuShortcut": true
    }
  }
}
```